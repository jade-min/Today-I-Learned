# [알고리즘 복기] SWEA D3 4406.모음이 보이지 않는 사람

## 20.01.10 (금)



---

### 문제 출처 : [SWEA(samsung SoftWare Expert Academy)]( https://swexpertacademy.com/main/main.do )

---



* 이 문제를 풀 때, 가장 먼저 들었던 생각

  * 단어가 주어지면 for문을 통해 탐색하다가 문제에서 주어진 모음 `'a'` , `'e'`,  `'i'`,  `'o'`,  `'u'` 5개 중 하나의 차례일 때, 그 문자를 제거하자

  

* ##### 문제를 푸는 로직( test- case 갯수 입력받고, 각 test - case 입력 알맞게 입력받기 생략 )

| 로직 Step | 로직 설명                                                    |
| --------- | ------------------------------------------------------------ |
| 1         | 5개의 모음을 list에 string 형태의 원소로 담고,<br />list를 `vowels(모음들)` 이라는 변수로 선언하자 |
| 2         | index를 활용하여 탐색하지 말고, list를 반복문으로 탐색하자<br />그러면 탐색의 대상은 바로 list의 원소들인 string이 되니 수월하다 |
| 3         | 반복문을 통해 list의 원소들을 탐색할 때, 탐색 대상 원소가 `vowels` 라는<br />list의 원소인지 아닌지에 대한 조건을 넣어 판별할 수 있도록 하자 |
| 4         | 바로 위에서 언급한 조건에 해당하는 원소를 반복문을 통해 탐색하다 만났을 때,<br />그 원소를 list에서 제거하자 |
| 5         | 그렇게 list 탐색이 끝나면, `vowels` 의 모음 5개를 제외한 나머지 string 원소들만 존재한다 |
| 6         | 문제에서 요구하는 출력형식은 string 형태이므로 list의 각각의 string들을<br />하나로 합쳐주는 과정이 필요하다 |
| 7         | 바로 위의 과정을 통해 하나의 string을 완성하였다면,<br />그것이 곧 문제에서 요구하는 답이므로 문제에서 요구하는 형식으로 출력하자 |



* 위의 로직을 토대로 코드를 작성하고 결과를 출력해보자

```python
"""
import sys
sys.stdin = open('4406.모음이 보이지 않는 사람_input.txt')
"""

T = int(input())

for tc in range(1, T+1):
    word = list(input())
    vowels = ['a', 'e', 'i', 'o', 'u'] # 1. 로직
    
    for char in word: # 2. 로직
        if char in vowels: # 3. 로직
            word.remove(char) # 4. 로직
    
    word = ''.join(word) #  5. & 6. 로직
    
    print("#{} {}".format(tc, word)) # 7. 로직
```



* 하지만 출력 결과는 처참했다

| 주어진 test-case          | 정답        | 본인이 도출한 결과    |
| ------------------------- | ----------- | --------------------- |
| congratulat **`io`** n    | #1 cngrtltn | **\#1 cngrtlt `o` n** |
| synth **`e`** t **`i`** c | #2 synthtc  | \#2 synthtc           |
| fl **`ui`** d             | \#3 fld     | **\#3 fl `i` d**      |

* 보이는가? `vowels` 에 속하는 모음이 연속해서 나오는 test-case에 한해서 정답과 다르게 출력되고 있다

  * 이를 통해 본인의 로직 중 잘못된 부분이 있다는 것을 알게 되었고, 그 잘못된 로직은

    ### **`4.`** 로직("조건에 해당하는 원소를 반복문을 통해 탐색하다 만났을 때, 그 원소를 list에서 제거하자")이다

  * 왜냐하면, 파이썬에서는 list에서 어떤 원소를 제거할 때, index 변화가 일어나기 때문이다. 자세한 설명은 아래와 같다.

  * (예) 'lion'

    * 'lion' 이라는 단어를 기본적인 반복문을 통해 탐색하면, 'l', 'i', 'o', 'n' 각각 하나의 문자를 탐색한다.
    * 탐색중에 두 번째 'i' 차례에서 'i'가 `vowels` 의 원소 중 하나이므로 이 'i' 원소를 제거하게 되고 'lion'은 'lon'이 된다.
    * 이 때, 'lion' 에서 가리키던 index는 'i' 였던 1이었는데 'lon' 이 되어 index == 1이 가리키는 것은 o가 되고 조건문을 수행했기 때문에 반복문으로 인해 다음 차례의 탐색이 이뤄지는데 이 과정에서 index는 2가 된다
    * 그래서 원래대로라면 'o'를 탐색하고 가야하는데 'o'의 차례를 건너뛰고 index는 'n' 을 바라보게 되는 것이다
    * 그러므로 처음 생각한 로직을 바꿔야 한다



* 원인을 알았으니 새로운 로직을 설계해보자.



* ##### 문제를 푸는 **`새로운`** 로직( test- case 갯수 입력받고, 각 test - case 입력 알맞게 입력받기 생략 )

| 로직 Step | 로직 설명                                                    |
| --------- | ------------------------------------------------------------ |
| 1         | 5개의 모음을 list에 string 형태의 원소로 담고,<br />list를 `vowels(모음들)` 이라는 변수로 선언하자 |
| **2**     | **`vowels` 의 원소가 아닌 다른 string을 연달아서 붙일 빈 string이 필요하다<br />비어있는 string을 `result` 라는 변수로 선언해주자** |
| 3         | index를 활용하여 탐색하지 말고, list를 반복문으로 탐색하자<br />그러면 탐색의 대상은 바로 list의 원소들인 string이 되니 수월하다 |
| 4         | 반복문을 통해 list의 원소들을 탐색할 때, 탐색 대상 원소가 `vowels` 라는<br />list의 원소인지 아닌지에 대한 조건을 넣어 판별할 수 있도록 하자 |
| **5**     | **바로 위에서 언급한 조건에 해당하는 원소가 아닌 문자를 반복문을 통해<br />탐색하다 만났을 때, 그 원소를 비어있는 string인 `result` 에 추가하자** |
| **6**     | **그렇게 list 탐색이 끝나면, `vowels` 의 모음 5개를 제외한 나머지 string 원소들이<br />모두 연결된 `result` 라는 하나의 string이 된다** |
| 7         | 바로 위의 과정을 통해 하나의 string을 완성하였다면,<br />그것이 곧 문제에서 요구하는 답이므로 문제에서 요구하는 형식으로 출력하자 |



* 위의 로직을 토대로 코드를 작성하고 결과를 출력해보자

```python
"""
import sys
sys.stdin = open('4406.모음이 보이지 않는 사람_input.txt')
"""

T = int(input())

for tc in range(1, T+1):
    word = list(input())
    vowels = ['a', 'e', 'i', 'o', 'u'] # 1. 로직
    result = "" # 2. 로직
    
    for char in word: # 3. 로직
        if char not in vowels: # 4. 로직
            result += char # 5. 로직 & 6. 로직
       
    print("#{} {}".format(tc, result)) # 7. 로직
```



* 출력 결과는 아래와 같다

| 주어진 test-case          | 정답        | 본인이 도출한 결과 |
| ------------------------- | ----------- | ------------------ |
| congratulat **`io`** n    | #1 cngrtltn | **\#1 cngrtltn**   |
| synth **`e`** t **`i`** c | #2 synthtc  | **\#2 synthtc**    |
| fl **`ui`** d             | \#3 fld     | **\#3 fld**        |

* SWEA에 제출한 결과, Pass를 받을 수 있었다.



* 처음 생각한 로직과 나중에 생각한 로직을 비교해보자

| 최초 로직 Step | 로직 설명                                                    | 나중 로직 Step | 로직 설명                                                    |
| -------------- | ------------------------------------------------------------ | -------------- | ------------------------------------------------------------ |
| 1              | 5개의 모음을 list에 string 형태의<br />원소로 담고, list를 `vowels(모음들)`<br />이라는 변수로 선언하자 | 1              | 5개의 모음을 list에 string 형태의<br />원소로 담고, list를 `vowels(모음들)` <br />이라는 변수로 선언하자 |
| 2              | index를 활용하여 탐색하지 말고,<br />list를 반복문으로 탐색하자<br />그러면 탐색의 대상은 바로<br />list의 원소들인 string이 되니 수월하다 | **2**          | **`vowels` 의 원소가 아닌<br />다른 string을 연달아서 붙일<br />빈 string이 필요하다<br />비어있는 string을<br />`result` 라는 변수로 선언해주자** |
| 3              | 반복문을 통해 list의 원소들을 탐색할 때,<br />탐색 대상 원소가 `vowels` 라는 list의<br />원소인지 아닌지에 대한 조건을 넣어<br />판별할 수 있도록 하자 | 3              | index를 활용하여 탐색하지 말고,<br />list를 반복문으로 탐색하자<br />그러면 탐색의 대상은 바로<br />list의 원소들인 string이 되니<br />수월하다 |
| ***4***        | ***바로 위에서 언급한 조건에<br />해당하는 원소를 반복문을 통해<br />탐색하다 만났을 때, 그 원소를<br />list에서 제거하자*** | 4              | 반복문을 통해<br />list의 원소들을 탐색할 때,<br />탐색 대상 원소가 `vowels` 라는<br />list의 원소인지 아닌지에 대한<br />조건을 넣어 판별할 수 있도록 하자 |
| 5              | 그렇게 list 탐색이 끝나면,<br />`vowels` 의 모음 5개를 제외한<br />나머지 string 원소들만 존재한다 | **5**          | **바로 위에서 언급한 조건에<br />해당하는 원소가 아닌 문자를<br />반복문을 통해 탐색하다 만났을 때,<br />그 원소를 비어있는 string인<br />`result` 에 추가하자** |
| 6              | 문제에서 요구하는 출력형식은<br />string 형태이므로 list의 각각의 string들을<br />하나로 합쳐주는 과정이 필요하다 | **6**          | **그렇게 list 탐색이 끝나면,<br />`vowels` 의 모음 5개를 제외한<br />나머지 string 원소들이<br />모두 연결된 `result` 라는<br />하나의 string이 된다** |
| 7              | 바로 위의 과정을 통해<br />하나의 string을 완성하였다면,<br />그것이 곧 문제에서 요구하는 답이므로<br />문제에서 요구하는 형식으로 출력하자 | 7              | 바로 위의 과정을 통해<br />하나의 string을 완성하였다면,<br />그것이 곧 문제에서 요구하는 답이므로<br />문제에서 요구하는 형식으로 출력하자 |



* 느낀 점
  * 문제를 풀 수 있는 방법은 1가지가 아닐 수도 있다
  * 문제를 접근할 수 있는, 해결할 수 있는 방법들을 여러 가지 측면에서 혹은 여러 가지 방법으로 생각해보자
  * 추상적인 부분을 단계별로 나눠 세우고(로직) 그 단계를 바탕으로 실제로 구현하니(코드)
    1. 마구잡이로 짜 내려가는 것보다 시간이 훨씬 단축된 기분이다
    2. 어느 부분에서 생각을 잘못했는지 알 수 있다
    3. 내가 알고 있는 지식과 실제 언어가 작동하는게 어떻게 다른지 알 수 있다
    4. 처음에 생각한 부분과 나중에 생각한 부분에서 어떤 차이가 있는지 한 눈에 볼 수 있다
  * <del>**알고리즘을 접하고, 배우고, 알게 된 지 1년이 지나고 있는 이 시점에 이런 문제를 푸는데 시간을 미친듯이 쏟아 붓다니 참으로 부끄럽다**</del>



* 복기를 마무리하며
  * (쉬운 문제든 어려운 문제든) 어떤 문제를 푸는데 시간이 오래 걸린다든지, 끙끙 앓아가는 소리내며 겨우 풀었다든지, 너무 어렵게 혹은 복잡하게 풀었다든지 등등 이렇게 ***찝찝*** 한 상태로 덮어버린다면 다음에 비슷한 유형의 문제, 비슷한 개념 혹은 아이디어를 묻는 문제를 접한다면 나의 실력은 여전히 제자리걸음일 것이다. 그렇다면 나는 앞으로 덮어두지 않겠다. 이 문제를 푸느라 쓴 시간이 아까워서라도 끝장을 내겠다. 끝장을 보겠다. 여기서 끝장이란, 다음에 이러한 유형의 문제를 만나면 헷갈리지 않고 바로 반응한다든지, 이러한 개념이구나 혹은 이러한 아이디어구나를 떠올려 시간을 단축시킬 정도로 그 문제를 파고들어 내 것으로 만드는 것을 뜻한다. 시간이 오래 걸릴지 모르겠으나, <del>**이미 1년 넘게 썼는데ㅠㅠ**</del> 앞으로 문제를 푸는데 소요되는 시간이 줄어들고 내가 성장할 수 있다면 그렇게 하겠다.
  * 물도 고여있으면 썩는다. 썩기 전에 진동을 주어 파동을 일으키자. **움직이자. 발버둥치자. 이 악물고.**